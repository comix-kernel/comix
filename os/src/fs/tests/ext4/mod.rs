use crate::devices::ram_disk::RamDisk;
use crate::fs::ext4::Ext4FileSystem;
use crate::vfs::error::FsError;
use crate::vfs::file_system::FileSystem;
use crate::vfs::inode::{FileMode, Inode};
use crate::vfs::dentry::{Dentry, DentryCache};
use alloc::sync::Arc;
use alloc::string::String;
use crate::devices::BlockDevice as VfsBlockDevice;
use crate::sync::SpinLock;
use lazy_static::lazy_static;

// Test helper functions (fixtures)

lazy_static! {
    /// 测试用的 Dentry Cache
    /// 用于保存测试中创建的 Dentry,防止被丢弃
    /// 注意: 使用唯一的 key 避免与全局 VFS 的 "/" 冲突
    static ref TEST_DENTRY_CACHE: SpinLock<DentryCache> = SpinLock::new(DentryCache::new());

    /// 测试计数器,用于生成唯一的路径
    static ref TEST_COUNTER: SpinLock<usize> = SpinLock::new(0);
}

/// Get the embedded ext4 test image
///
/// This image is generated by build.rs at compile time
fn get_ext4_image() -> &'static [u8] {
    include_bytes!(env!("EXT4_FS_IMAGE"))
}

/// Create a test RamDisk from the embedded ext4 image
///
/// # Returns
/// RamDisk instance with valid ext4 filesystem
pub fn create_test_ramdisk() -> Arc<RamDisk> {
    const BLOCK_SIZE: usize = 4096; // Ext4 standard block size
    const DEVICE_ID: usize = 0;

    let image_data = get_ext4_image().to_vec();
    RamDisk::from_bytes(image_data, BLOCK_SIZE, DEVICE_ID)
}

/// Create a test Ext4 filesystem with root dentry
///
/// The root dentry is cached in TEST_DENTRY_CACHE to keep it alive
/// Uses a unique path to avoid conflicts with global VFS "/"
///
/// # Returns
/// (Ext4FileSystem, root Dentry)
pub fn create_test_ext4_with_root() -> (Arc<Ext4FileSystem>, Arc<Dentry>) {
    let ramdisk = create_test_ramdisk();
    let fs = Ext4FileSystem::open(ramdisk).expect("Failed to create Ext4FileSystem");

    // 为每个测试生成唯一的虚拟根路径,避免与全局 "/" 冲突
    let test_id = {
        let mut counter = TEST_COUNTER.lock();
        *counter += 1;
        *counter
    };
    let unique_root_path = alloc::format!("/ext4_test_{}", test_id);

    // 重要: 必须使用 fs.root_inode() 返回的同一个 Arc<dyn Inode>
    let root_inode = fs.root_inode();

    // 使用唯一路径创建 dentry,避免缓存冲突
    let root_dentry = Dentry::new(unique_root_path, root_inode);

    // 将 root_dentry 插入缓存,保持其存活
    TEST_DENTRY_CACHE.lock().insert(&root_dentry);

    (fs, root_dentry)
}

/// Create a test Ext4 filesystem
///
/// The root inode will have its dentry properly set and cached
///
/// # Returns
/// Ext4FileSystem instance with root dentry properly set up
pub fn create_test_ext4() -> Arc<Ext4FileSystem> {
    let (fs, _root_dentry) = create_test_ext4_with_root();
    // root_dentry 已经被缓存,不会被丢弃
    fs
}

/// Get root dentry for a filesystem
///
/// Note: Not commonly used, prefer using create_test_ext4_with_root()
///
/// # Returns
/// Root dentry
pub fn get_root_dentry(fs: &Arc<Ext4FileSystem>) -> Arc<Dentry> {
    let root_inode = fs.root_inode();

    // 生成唯一路径
    let test_id = {
        let mut counter = TEST_COUNTER.lock();
        *counter += 1;
        *counter
    };
    let unique_root_path = alloc::format!("/ext4_test_{}", test_id);

    let root_dentry = Dentry::new(unique_root_path, root_inode);
    TEST_DENTRY_CACHE.lock().insert(&root_dentry);
    root_dentry
}

/// Create a file with content in test Ext4 filesystem
///
/// # Arguments
/// - `fs`: Ext4 filesystem instance
/// - `name`: File name
/// - `content`: File content
///
/// # Returns
/// Created Inode
pub fn create_test_file_with_content(
    fs: &Arc<Ext4FileSystem>,
    name: &str,
    content: &[u8],
) -> Result<Arc<dyn Inode>, FsError> {
    let root = fs.root_inode();
    let inode = root.create(name, FileMode::from_bits_truncate(0o644))?;
    inode.write_at(0, content)?;
    Ok(inode)
}

/// Create a directory in test Ext4 filesystem
///
/// # Arguments
/// - `fs`: Ext4 filesystem instance
/// - `name`: Directory name
///
/// # Returns
/// Created directory Inode
pub fn create_test_dir(fs: &Arc<Ext4FileSystem>, name: &str) -> Result<Arc<dyn Inode>, FsError> {
    let root = fs.root_inode();
    root.mkdir(name, FileMode::from_bits_truncate(0o755))
}

// Export test modules
pub mod ext4_basic;
pub mod ext4_directory;
pub mod ext4_metadata;
pub mod ext4_io;
pub mod ext4_error;
pub mod ext4_integration;
