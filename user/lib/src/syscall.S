.globl __syscall
__syscall:
    /* ------------------------------------------------------------------
     * 1. 准备上下文（调用者保存寄存器）
     * 保存内核或 ecall 可能破坏的寄存器，主要是把 C 语言的参数 a0-a6 保存起来
     * 以便我们可以安全地重新安排寄存器以符合系统调用的 ABI。
     * 需要保存的寄存器包括 a0,a1,a2,a3,a4,a5,a6,a7（按 C 约定 a7 也可能被使用）。
     * 为简单起见，这里着重保存将要被交换的寄存器（a0-a6）以及一个临时寄存器。
     * ------------------------------------------------------------------ */
    addi    sp, sp, -8 * 8  /* 为 8 个寄存器分配 64 字节栈空间 */
    sd      a0, 0 * 8(sp)   /* 保存 C 的 'number'（a0） */
    sd      a1, 1 * 8(sp)   /* 保存 C 的 'arg1'（a1） */
    sd      a2, 2 * 8(sp)   /* 保存 C 的 'arg2'（a2） */
    sd      a3, 3 * 8(sp)   /* 保存 C 的 'arg3'（a3） */
    sd      a4, 4 * 8(sp)   /* 保存 C 的 'arg4'（a4） */
    sd      a5, 5 * 8(sp)   /* 保存 C 的 'arg5'（a5） */
    sd      a6, 6 * 8(sp)   /* 保存 C 的 'arg6'（a6）——第 7 个 C 参数 */
    sd      t0, 7 * 8(sp)   /* 保存临时寄存器 */


    /* ------------------------------------------------------------------
     * 2. 设置 ABI 寄存器
     * 根据 C 语言 ABI（函数调用约定）把参数搬到系统调用约定所要求的寄存器：
     * C 的 'number'（在 a0）移动到系统调用号寄存器 a7；
     * C 的 'arg1'（在 a1）移动到系统调用参数寄存器 a0；依次类推。
     * C 的 'arg6'（在 a6）移动到系统调用寄存器 a5。
     * ------------------------------------------------------------------ */
    mv      a7, a0          
    mv      a0, a1  
    mv      a1, a2 
    mv      a2, a3 
    mv      a3, a4 
    mv      a4, a5 
    mv      a5, a6

    /* ------------------------------------------------------------------
     * 3. 执行系统调用
     * ------------------------------------------------------------------ */
    ecall                   /* 触发系统调用，进入内核 */

    /* ------------------------------------------------------------------
     * 4. 系统调用返回与错误检查
     * 内核的返回值现在位于 a0。
     * ------------------------------------------------------------------ */
    
    mv      t0, a0     
    
    /* 检查是否为错误（Linux ABI：若 a0 < 0 则表示错误） */
    blt     a0, zero, .Lsyscall_error
    
    j       .Lsyscall_success


.Lsyscall_error:
    /* Linux ABI 的错误处理：
     * 1. 将返回值设为 -1。
     * 2. errno 应设置为正的错误码（a0 = -errno）。
     * 3. 最终使函数返回 -1。
     */
    neg     a1, a0     
    
    /* 注意：为简化示例，这里跳过了设置线程局部 errno 的步骤；真实的 C 库
     * 应调用相应函数用 a1 设置 errno。 */
    
    li      a0, -1      
    j       .Lsyscall_cleanup


.Lsyscall_success:
    /* 成功分支：t0 中保存了内核返回值，把它恢复到 a0 */
    mv      a0, t0   

.Lsyscall_cleanup:
    /* ------------------------------------------------------------------
     * 5. 清理并返回
     * 恢复先前保存的寄存器并返回到 C 代码。
     * ------------------------------------------------------------------ */
    ld      t0, 7 * 8(sp) 
    ld      a6, 6 * 8(sp) 
    ld      a5, 5 * 8(sp)
    ld      a4, 4 * 8(sp)
    ld      a3, 3 * 8(sp)
    ld      a2, 2 * 8(sp)
    ld      a1, 1 * 8(sp)
    
    /* 注意：a0（返回值）保持为正确的返回值，不需要恢复。 */
    
    addi    sp, sp, 8 * 8  
    ret                    